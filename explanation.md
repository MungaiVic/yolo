# IP 2 Project

- This is the IP 2 project at Moringa School.
- It explains the reasoning behind the choices made in the project.

## 1. Choice of the base image on which to build each container

I've chosen Node Alpine images as the base for each container. The decision is based on a few reasons:

- Size: Alpine images are renowned for their small size, which significantly decreases build times and bandwidth usage when pulling the images.
- Security: Alpine Linux has a small attack surface, making it less vulnerable to security issues compared to larger base images.
- Node.js Compatibility: Being a Node.js application, we need an environment where Node.js runs smoothly. Node Alpine images are explicitly built for this purpose, which ensures compatibility and smooth running of our Node.js applications.

## 2. Dockerfile directives used in the creation and running of each container

The Dockerfile directives used have been carefully selected to ensure an optimal and efficient container creation and operation process:

- `FROM`: This sets the base image for the Docker container. As mentioned, we're using Node Alpine images for their compactness, security, and compatibility with Node.js.
- `WORKDIR`: This sets the working directory in the container. All subsequent commands (COPY, RUN, etc.) are executed in this directory.
- `COPY`: This copies the application code and other necessary files from the local machine - into the Docker container.
- `RUN`: This allows for executing commands necessary for building the application, such as installing dependencies.
- `EXPOSE`: This exposes a port on the container to allow for network communication between the container and the outside world.
- `CMD`: This is the default command that will be executed when the container is run.

## 3. Docker-compose Networking

Networking in Docker-compose has been implemented considering port allocation and a bridge network for secure communication between containers:

- Port Allocation: The ports directive in Docker-compose allows mapping of ports between the container and the host. This enables the application to be accessed outside the Docker environment.
- Bridge Network: This is the default network type created by Docker. It allows all containers connected to it to communicate, while isolating them from other networks. The networks directive in Docker-compose is used to specify this.

## 4. Docker-compose volume definition and usage

Volumes are defined and used in Docker-compose to persist data generated by and used by Docker containers:

- Definition: Volumes are defined under the volumes directive in the Docker-compose file.
- Usage: They are used to persist data across container shutdown and startup. For instance, we might want to persist database data so that we don't lose our entire database each time the container restarts.

## 5. Git workflow used to achieve the task

A Git Feature Branch workflow was used:

- forking: The repository was forked to create a copy of the original repository.
- cloning: The forked repository was cloned to the local machine.
- committing: Changes were made to the code and committed to the local repository.
- pushing: The changes were pushed to the remote repository.

## 6. Successful running of the applications and debugging measures applied

The applications were successfully run using the Docker containers. Whenever issues were encountered, the following debugging measures were applied:

- Checking Logs: Docker logs were checked to understand any runtime errors or issues.
- Docker Inspect: This command was used to view detailed information about containers, networks, or volumes.
- Rebuilding Images: In case of configuration changes or Dockerfile changes, images were rebuilt and containers were restarted.

## 7. Good practices such as Docker image tag naming standards for ease of identification of images and containers

Adopting best practices for Docker image tag naming helps in organizing and managing Docker images effectively. For instance,

- Semantic Versioning: Each image tag includes the version of the application it represents, adhering to semantic versioning (major.minor.patch).
- Use of semantic versioning allows for easy identification of the version of the application represented by the image.
